# On-Target Unit-Testing [iOS]

In order to test core on device, we need an iOS app, and hence an Xcode
project.

The common workflow is:

$ sh build.sh build-test-ios-app
$ sh build.sh test-ios-app

The first builds an Xcode project. The second tests the Xcode project on a
device using xcodebuild.

Since the test files can be expected to be changed more quickly than the
contents of this subdirectory, we use GYP to generate fresh Xcode projects.
(See also the build-test-ios-app target in build.sh.)

The Xcode project can then be "tested" to run the tests on device, using either
Xcode, xcodebuild (see also the test-ios-app target in build.sh), Instruments,
or the command-line instruments (see also the leak-test-ios-app target in
build.sh).

## build-test-ios-app options

### -d

The "revertability" to graphical tools is useful for debuggning, in which case,
you should specify specify the additional flag -d to the build-test-ios-app
target, e.g.

$ sh build.sh build-test-ios-app -d

### -a

By default, the Xcode project built, builds the app for all standard
architectures, including 64-bit architectures. (Currently, armv7, armv7s, and
arm64.) This means that the app is compiled and tested for all of these
architectures when you do test-ios-app.

We have thus far failed to figure out a way to report the target architecture
to stdout before or after we test for a particular one. We've posted a question
about this on StackOverflow: http://stackoverflow.com/questions/23934862/.

In the meanwhile, you can specify the target archtecture (or a space-separated
list thereof) as an option, e.g.

$ sh build.sh build-test-ios-app -a armv7
$ sh build.sh build-test-ios-app -a "armv7 armv7s"

## test-ios-app options

test-ios-app forwards all options that you add to xcodebuild. See XCODEBUILD(1)
for more details.

### -destination

This specifies which iOS device the app should be tested. The available
platforms are iOS, and iOS Simulator. In either casem you need a device name,
these are listed in Xcode. Examples:

$ sh build.sh test-ios-app -destination "platform=iOS,name=realm's iPad"
$ sh build.sh test-ios-app -destination "platform=iOS Simulator,name=iPad"

The first example above is the default.

### -arch

This is an alternative to specifying -a for build-test-ios-app, with the
exception that you can't specify multiple architectures. It follows that this:

$ sh build.sh build-test-ios-app -a armv7
$ sh build.sh test-ios-app

Has the same effect as this:

$ sh build.sh build-test-ios-app
$ sh build.sh test-ios-app -arch armv7

## Implementation Details

The contents of the template subdirectory is used to generate an app
subdirectory containing the iOS app, i.e. an App and AppTests sub-subdirectory
+ project files.

To get everything to be fully automatic we use a couple dirty tricks:

* We have both an App and a AppTests target, which allows us to define a test
scheme - necessary to use xcodebuild test. The scheme is built by grep'ing the
project file generated by gyp, and by using the template App.scheme.sh. The
test target, i.e. AppTests subdirectory is used for little else than this.

* We call the tests from AppDelegate.mm, when the app has finished
loading. The app has finished loading whenever it is started the usual way,
using an inspector, or using a test scheme.

* We also redirect the XML output to standard out since there is seemingly no
easy way of fetching XML files from an iOS device.
